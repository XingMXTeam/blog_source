---
title: "计算机底层"
date: 2021-08-24
tags:
- computer
description: "关于计算机底层的理解"
---

## 编码原理

### 数字编码

**为什么会有补码？**
补码是为了方便计算机的运算, 计算计比较容易做加法。 比如5+（-3）通过补码计算
0101（5）
0011（3） -> 取反 1100 ->加一 1101 
0101+1101=100010 截断后 0010（-2） 符合预期结果（原码： 首位为符号位 反码： 除了符号位，所有位取反 都不满足预期）

补码定义： 正数不变，负数取反并且+1 

**为什么表示范围是[-128,127] ?**
4位二进制补码表示： 
0000（-0） 0000（0） 
1111（-1)  0001（1） 
1110 (-2)  0010（2） 
...       ...
1011(-5)   0101（5） 
1010(-6)   0110（6） 
1001(-7)   0111（7）

范围是 [-7, 7] 1000没有被表示 刚好就会-8  所以最终是[-8, 7] 符号位参与运算，但是结果符合预期
-8的补码表示： 1000（原） -> 取反 0111 -> 加一 1000

**为什么补码要反码+1？**
4位二进制补码表示： 
0000（-0） 0000（0） 
1111（-1)  0001（1） 
1110 (-2)  0010（2） 
...       ...
1011(-5)   0101（5） 
1010(-6)   0110（6） 
1001(-7)   0111（7）

+1后，0位表示一致，并且符号位参与运算刚好符合预期

**为什么小数会有精度问题？**
因为二进制的小数只能用固定的数字组合，比如0.2 无法用二进制组合精确表示

### 文本编码

**概念**：  

码表（字符集）： 字符和数字的对应关系 （接口）
字符编码： 具体实现
码点： 表中的每个数字（可能由一个或者多个码元组成）

**发展轨迹**：  
ASCII(英文和特殊字符) : 一个字节中的7位 -> EASCII字符集： ISO 8859-1  -> GB2312 -> GBK： GBK编码（汉字） -> GB18030 -> Unicode字符集 ：一般unicode编码指UTF-16编码 变长编码、2字节码元、有字节序问题， UTF-8是变长编码 单字节码元 无字节序问题

初始化->本地化（GB表示国标）->国际化->效率化

### 多媒体编码

音频： 一定时间内采集有限的样本表示。 采样率和模拟信号频率有关，每秒40000个样本 编码方式AAC
图像： 光栅图（解析度： 单位面积像素数，色彩深度： 像素位数量）/矢量图（数学公式计算像素分布）
视频： 帧 由图片构成，多帧构成视频流。 编码方式MPEG-1, MPEG-2, MPEG-4, H.264, H.265

## 运算的本质

### 概念

逻辑运算中的与、或、非、异或

通过逻辑模拟可以实现以上的逻辑运算。输入是开关，输出一般是LED灯(有颜色的灯)。芯片一般是实现逻辑运算，比如7486（异或门）芯片，会暴露一些引脚出来，比如一个接电源，一个接地，其他接输入，表示输出等

### 半加器：不考虑进位， 单位

Cout = X * Y
S = X ⊕ Y

### 全加器: 考虑进位， 单位

``` 
S = X ⊕ Y ⊕ Cin
// both the X and Y values are true, or if either the X or Y value is true and the Cin is true
Cout = (X*Y) + ((X⊕Y)*Cin)
```

### 两位加法机

### 多位加法机
### 记忆加法机

保存上次计算的结果

### 选择加法机

多弄几个记忆加法器，避免输错时重新来过。

### 自动加法机

按一下开关，自动自动输入并且把所有数字加起来。 

### 自由加法机

可控制只计算部分的数字

### 对比现代计算机

目前的计算机能进行10亿次的加法运算。计算机包含
1 存储器（存储箱：用于存储输入的数字，要执行的代码，计算的结果）
2 运算器（累加器：计算两个数字相加）
3 控制器（控制板：切换开关）
4 输入设备（输入面板：输入开关）
5 输出设备（输出灯泡：灯泡现实输出数据）
<!-- 
键盘输入数字->产生电压（高低电平 信号？） 触发输入总线中断程序->数字输入到内存区域，同时分配内存地址。 而加法机在操作输入面板每输入一个数字，需要通过选择器制定记忆盒子来存储数组，记忆盒子的编号对应了选择器的序号，也就是内存地址

计算机加法按键，计算机会将数字所在内存地址加载到CPU进行加法运算。加法机需要写代码到记忆盒子，第一行是加法操作代码，第二三行是地址编码。编码完成后，启动异步计数器（周期性扫描记忆盒子的代码），逐行执行，异步计数器执行完后，记忆盒子的数据就被加载到累加器。数据通过寻址（通过译码器寻址数据记忆盒子的过程称为寻址过程）传输到累加器运算后存储到锁存器盒子，然后通过灯泡显示出来。 -->

<!-- 以上包含了：输入、输出、内存、寻址、译码、指令、算术逻辑单元等概念 -->

编程就是把一系列指令存到内存，让计算机逐步执行这些指令。把一些常用指令封装起来就形成了操作系统。

### 虚拟电路模拟

https://exp.xiaogd.net/circuitjs1-zh/circuitjs.html

### 解释器和编译器的区别

代码在执行前都需要通过语法解析器，将输入的代码字符串转换为AST(抽象语法树)

一般解释器解释执行程序时会经过如下步骤：
1 Lexer（词法分析器）读取代码，将代码转换为token序列
2 Parser(语法分析器) 把读到的Token序列转换为AST（大部分情况Lexer是Parser的一部分）
3 对AST进行Lowering(化简AST)或者Desugar(把语法糖的AST节点转换为标准等价AST节点)
4 Interpreter递归执行AST

解释器直接解释执行AST，并返回最终结果：

``` js
function interpret(ast) {
  switch(ast.type) {
    case 'number': return ast.value;
    case 'negative': return -interpret(ast.value);
    case 'op': 
      switch(ast.value) {
        case '+': interpret(ast.v1) + interpret(ast.v2);
      }
  }
}
```

编译器: 把AST翻译成目标语言，比如汇编

``` js
// 假定为目标机器为栈式虚拟机，然后通过exec函数执行
function compile(ast) {
  switch(ast.type) {
    case 'number': return "ds.push("+ast.value+")\n";
    case 'negative':
      return "ds.push(-ds.pop())\n";
    case 'op':
      return compile(ast.v1) + compile(ast.v2) + "ds.push(ds.pop() " + ast.value + "  ds.pop())\n";
  }
}

```

将ast的遍历和实现分离，每一步操作封装为单独的函数

``` js
function interpret(ast) {
  switch(ast.type) {
    case 'number': return ast.value;
    case 'negative': return -interpret(ast.value);
    case 'op': 
      switch(ast.value) {
        case '+': interpret(ast.v1) + interpret(ast.v2);
      }
  }
}
```

## 代码的本质

通过代码控制机器，代码是人阅读的指令。 主要有两大要素数据和操作（判断、选择、循环、分支等）。


### 内存模型

[运算的本质](#运算的本质)的锁存器（64位构成的庞大数组），本质就是内存。

顺序执行： 代码编译成一条条指令还在到内存（操作系统分配的执行区域），计数器逐步执行内存的执行，返回结果

分支选择： 跳到对应地址执行指令

嵌套执行： 函数执行会在内存开辟一组连续的内存空间。 函数代码执行前根据参数数量、参数大小，计算分配栈空间，栈底为内存高地址方向
执行过程的活动记录，由标记顶部位置的帧指针和标记底部位置的栈指针定义。当执行完毕，帧指针指向下一条指令地址

未完待续...
